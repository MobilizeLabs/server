package org.ohmage.domain;

import java.io.ByteArrayOutputStream;
import java.io.IOException;

import org.apache.avro.AvroRuntimeException;
import org.apache.avro.AvroTypeException;
import org.apache.avro.Schema;
import org.apache.avro.generic.GenericContainer;
import org.apache.avro.generic.GenericDatumReader;
import org.apache.avro.generic.GenericDatumWriter;
import org.apache.avro.io.BinaryEncoder;
import org.apache.avro.io.Decoder;
import org.apache.avro.io.DecoderFactory;
import org.apache.avro.io.EncoderFactory;
import org.codehaus.jackson.JsonNode;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.format.ISODateTimeFormat;
import org.ohmage.domain.Observer.Stream;
import org.ohmage.exception.DomainException;

/**
 * This class represents a set of data generated by a stream. It retains the
 * reference to the stream that was used to decode the data.
 *
 * @author John Jenkins
 */
public class DataStream {
	private static final DecoderFactory DECODER_FACTORY = new DecoderFactory();
	private static final EncoderFactory ENCODER_FACTORY = new EncoderFactory();
	
	/**
	 * This class represents the meta-data for a data stream. All fields are 
	 * optional. This class is immutable and, therefore, thread-safe.
	 *
	 * @author John Jenkins
	 */
	public static class MetaData {
		/**
		 * This class is responsible for building new MetaData objects. This
		 * class is mutable and, therefore, not thread-safe.
		 *
		 * @author John Jenkins
		 */
		public static class Builder {
			private String id = null;
			private DateTime timestamp = null;
			private Location location = null;
			
			/**
			 * Creates an empty builder.
			 */
			public Builder() {};
			
			/**
			 * Sets the ID.
			 * 
			 * @param id The ID.
			 */
			public void setId(final String id) {
				this.id = id;
			}
			
			/**
			 * Decomposes a JsonNode from Jackson into an ID and stores it.
			 * 
			 * @param metaDataNode The meta-data node from an upload.
			 * 
			 * @throws DomainException Never thrown.
			 */
			public void setId(
					final JsonNode metaDataNode)
					throws DomainException {
				
				if(metaDataNode == null) {
					return;
				}
				
				if(metaDataNode.has("id")) {
					JsonNode idNode = metaDataNode.get("id");
					
					if(idNode.isValueNode()) {
						this.id = idNode.asText();
					}
					else {
						throw new DomainException(
							"The 'id' is not a value.");
					}
				}
			}
			
			/**
			 * Sets the timestamp.
			 * 
			 * @param timetamp The timestamp.
			 */
			public void setTimestamp(final DateTime timestamp) {
				this.timestamp = timestamp;
			}
			
			/**
			 * Decomposes a JsonNode from Jackson into a timestamp and stores
			 * it.
			 * 
			 * @param metaDataNode The meta-data node from an upload.
			 * 
			 * @throws DomainException The timestamp node was invalid.
			 */
			public void setTimestamp(
					final JsonNode metaDataNode) 
					throws DomainException {
				
				if(metaDataNode == null) {
					return;
				}
				
				if(metaDataNode.has("timestamp")) {
					JsonNode timestampNode = metaDataNode.get("timestamp");
					
					if(! timestampNode.isTextual()) {
						throw new DomainException(
							"The timestamp value was not a string.");
					}
					
					try {
						timestamp = 
							ISODateTimeFormat.dateTime().parseDateTime(
								timestampNode.getTextValue());
					}
					catch(IllegalArgumentException e) {
						throw new DomainException(
							"The timestamp was not a valid ISO 8601 timestamp.",
							e);
					}
				}
				else if(metaDataNode.has("time")) {
					JsonNode timeNode = metaDataNode.get("time");
					
					if(! timeNode.isNumber()) {
						throw new DomainException("The time isn't a number.");
					}
					long time = timeNode.getNumberValue().longValue();
					
					DateTimeZone timeZone = DateTimeZone.UTC;
					if(metaDataNode.has("timezone")) {
						JsonNode timeZoneNode = metaDataNode.get("timezone");
						
						if(! timeZoneNode.isTextual()) {
							throw new DomainException(
								"The time zone is not a string.");
						}
						
						try {
							timeZone = 
								DateTimeZone.forID(
									metaDataNode.getTextValue());
						}
						catch(IllegalArgumentException e) {
							throw new DomainException(
								"The time zone is unknown.");
						}
					}
					
					timestamp = new DateTime(time, timeZone);
				}
			}
			
			/**
			 * Sets the location.
			 * 
			 * @param location The Location object.
			 */
			public void setLocation(final Location location) {
				this.location = location;
			}
			
			/**
			 * Decomposes a JsonNode from Jackson into a location and stores
			 * it.
			 * 
			 * @param metaDataNode The meta-data node from an upload.
			 * 
			 * @throws DomainException The location node was invalid.
			 */
			public void setLocation(
					final JsonNode metaDataNode) 
					throws DomainException {
				
				if(metaDataNode == null) {
					return;
				}
				
				JsonNode locationNode = metaDataNode.get("location");
				if(locationNode != null) {
					location = new Location(locationNode);
				}
			}
			
			/**
			 * Builds the MetaData object.
			 * 
			 * @return The MetaData object.
			 */
			public MetaData build() {
				return new MetaData(id, timestamp, location);
			}
		}
		
		private final String id;
		private final DateTime timestamp;
		private final Location location;
		
		/**
		 * Creates a new MetaData object.
		 * 
		 * @param timestamp The time stamp for this meta-data.
		 * 
		 * @param location The location for this meta-data.
		 */
		public MetaData(
				final String id,
				final DateTime timestamp, 
				final Location location) {
			
			this.id = id;
			this.timestamp = timestamp;
			this.location = location;
		}
		
		/**
		 * Returns the ID.
		 * 
		 * @return The ID.
		 */
		public String getId() {
			return id;
		}

		/**
		 * Returns timestamp.
		 *
		 * @return The timestamp.
		 */
		public DateTime getTimestamp() {
			return timestamp;
		}

		/**
		 * Returns location.
		 *
		 * @return The location.
		 */
		public Location getLocation() {
			return location;
		}
	}
	private final MetaData metaData;
	
	private final Stream stream;
	
	private final GenericContainer dataContainer;
	
	private BinaryEncoder binaryEncoder = null;

	/**
	 * Creates a new DataStream from binary data generated by Avro.
	 * 
	 * @param stream The stream that contains the definition on how to decode
	 *				 the data.
	 *
	 * @param metaData The meta-data.
	 * 
	 * @param data The data.
	 * 
	 * @throws DomainException One of the parameters is invalid or null.
	 */
	public DataStream(
			final Stream stream,
			final MetaData metaData,
			final byte[] data) 
			throws DomainException {

		if(stream == null) {
			throw new DomainException("The stream is null.");
		}
		else if(data == null) {
			throw new DomainException("The data is null.");
		}
		else if(data.length == 0) {
			throw new DomainException("The data is empty.");
		}
		
		// Save the reference to the stream.
		this.stream = stream;
		
		// Save the meta-data.
		this.metaData = metaData;
		
		// Decode the data from the stream.
		GenericDatumReader<GenericContainer> genericReader =
			new GenericDatumReader<GenericContainer>(stream.getSchema());
		try {
			dataContainer =
				genericReader.read(
					null, 
					DECODER_FACTORY.binaryDecoder(data, null));
		}
		catch(IOException e) {
			throw new DomainException(e);
		}
		catch(AvroRuntimeException e) {
			throw new DomainException("The data is invalid.", e);
		}
	}
	
	/**
	 * Creates a new DataStream from JSON data represented by a string.
	 * 
	 * @param stream The stream that contains the definition on how to decode
	 *				 the data.
	 *
	 * @param metaData The meta-data.
	 * 
	 * @param data The data.
	 * 
	 * @throws DomainException One of the parameters is invalid or null.
	 */
	public DataStream(
			final Stream stream,
			final MetaData metaData,
			final String data)
			throws DomainException {
		
		if(stream == null) {
			throw new DomainException("The stream is null.");
		}
		else if(data == null) {
			throw new DomainException("The data is null.");
		}
		
		// Save the reference to the stream.
		this.stream = stream;
		
		// Save the meta-data.
		this.metaData = metaData;
		
		// Decode the data.
		Schema schema = stream.getSchema();
		Decoder decoder;
		try {
			decoder = (new DecoderFactory()).jsonDecoder(schema, data);
		}
		catch(IOException e) {
			throw new DomainException("Could not read the data.", e);
		}
		
		// Create the JSON reader.
		GenericDatumReader<GenericContainer> reader =
			new GenericDatumReader<GenericContainer>(schema);
		
		// Read into the container.
		try {
			dataContainer = reader.read(null, decoder);
		}
		catch(AvroTypeException e) {
			throw new DomainException(
				"The data was invalid.",
				e);
		}
		catch(IOException e) {
			throw new DomainException(
				"Could not create the data container.", 
				e);
		}
	}

	/**
	 * Returns the stream.
	 *
	 * @return The stream.
	 */
	public Stream getStream() {
		return stream;
	}

	/**
	 * Returns the meta-data.
	 *
	 * @return The meta-data.
	 */
	public MetaData getMetaData() {
		return metaData;
	}
	
	/**
	 * Returns the binary data as a byte array.
	 * 
	 * @return The binary data as a byte array.
	 */
	public byte[] getBinaryData() throws DomainException {
		// Create the output stream.
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		
		// Create or reinitialize the binary encoder.
		binaryEncoder = ENCODER_FACTORY.binaryEncoder(out, binaryEncoder);
		
		// Create a writer.
		GenericDatumWriter<GenericContainer> writer =
			new GenericDatumWriter<GenericContainer>(stream.getSchema());
		
		// Write the data and flush the encoder.
		try {
			writer.write(dataContainer, binaryEncoder);
			binaryEncoder.flush();
		}
		catch(IOException e) {
			throw new DomainException(
				"There was an error writing the data.", 
				e);
		}
		
		// Return the result.
		return out.toByteArray();
	}
	
	/**
	 * Returns a generic container for the data.
	 * 
	 * @return A generic container for the data.
	 */
	public GenericContainer getData() {
		return dataContainer;
	}
}