package org.ohmage.domain.campaign.prompt;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import org.json.JSONException;
import org.json.JSONObject;

/**
 * This class represents prompts that have a set of choices that are defined by
 * the campaign configuration and have a set of choices that can be added and
 * removed by a user.
 * 
 * @author John Jenkins
 */
public abstract class CustomChoicePrompt extends ChoicePrompt {
	private final Map<Integer, LabelValuePair> customChoices;
	
	/**
	 * Creates a custom choice prompt.
	 * 
	 * @param id The unique identifier for the prompt within its survey item
	 * 			 group.
	 * 
	 * @param condition The condition determining if this prompt should be
	 * 					displayed.
	 * 
	 * @param unit The unit value for this prompt.
	 * 
	 * @param text The text to be displayed to the user for this prompt.
	 * 
	 * @param abbreviatedText An abbreviated version of the text to be 
	 * 						  displayed to the user for this prompt.
	 * 
	 * @param explanationText A more-verbose version of the text to be 
	 * 						  displayed to the user for this prompt.
	 * 
	 * @param skippable Whether or not this prompt may be skipped.
	 * 
	 * @param skipLabel The text to show to the user indicating that the prompt
	 * 					may be skipped.
	 * 
	 * @param displayType This prompt's
	 * 					 {@link org.ohmage.domain.campaign.Prompt.DisplayType}.
	 * 
	 * @param displayLabel The display label for this prompt.
	 * 
	 * @param choices A map of choices from their integer key value to their
	 * 				  label-value pairs.
	 * 
	 * @param customChoices A map of user-defined map of choices from their
	 * 						integer key value to their lable-value pairs.
	 * 
	 * @param type This prompt's 
	 * 			   {@link org.ohmage.domain.campaign.Prompt.Type}.
	 * 
	 * @param index This prompt's index in its container's list of survey 
	 * 				items.
	 * 
	 * @throws IllegalArgumentException Thrown if any of the required 
	 * 									parameters are missing or invalid. 
	 */
	public CustomChoicePrompt(final String id, final String condition, 
			final String unit, final String text, 
			final String abbreviatedText, final String explanationText,
			final boolean skippable, final String skipLabel,
			final DisplayType displayType, final String displayLabel,
			final Map<Integer, LabelValuePair> choices,
			final Map<Integer, LabelValuePair> customChoices, 
			final Type type, final int index) {
		
		super(id, condition, unit, text, abbreviatedText, explanationText,
				skippable, skipLabel, displayType, displayLabel, 
				choices, type, index);
		
		this.customChoices = new HashMap<Integer, LabelValuePair>(customChoices);
	}
	
	/**
	 * Returns an unmodifiable map of custom choices generated by the user.
	 * 
	 * @return An unmodifiable map of custom choices generated by the user. 
	 */
	public Map<Integer, LabelValuePair> getCustomChoices() {
		return Collections.unmodifiableMap(customChoices);
	}
	
	/**
	 * Returns all of the possible choices, static and custom, as an
	 * unmodifiable map.
	 * 
	 * @return An unmodifiable map of all of the choices, static and custom.
	 */
	public Map<Integer, LabelValuePair> getAllChoices() {
		Map<Integer, LabelValuePair> combinedMap = new HashMap<Integer, LabelValuePair>(customChoices);
		combinedMap.putAll(getChoices());
		
		return Collections.unmodifiableMap(combinedMap);
	}
	
	/**
	 * Adds a new choice to the list of custom choices.
	 * 
	 * @param key The choice's key. Required.
	 * 
	 * @param label The choice's label. Required.
	 * 
	 * @param value The choice's value. Optional.
	 * 
	 * @throws IllegalArgumentException Thrown if the 'key' or label are 
	 * 									invalid or the 'key' already exists for
	 * 									a static or custom choice.
	 */
	public void addChoice(final Integer key, final String label, 
			final Number value) {
		
		addChoice(key, new LabelValuePair(label, value));
	}
	
	/**
	 * Adds a new choice to the list of custom choices.
	 * 
	 * @param key The choice's key. Required.
	 * 
	 * @param labelValuePair The choice's label-value pair. Required.
	 * 
	 * @throws IllegalArgumentException Thrown if the 'key' or label-value pair
	 * 									are invalid or if such a choice already
	 * 									exist with the given 'key'.
	 */
	public void addChoice(final Integer key, 
			final LabelValuePair labelValuePair) {
		
		if(key == null) {
			throw new IllegalArgumentException("The key cannot be null.");
		}
		else if(key < 0) {
			throw new IllegalArgumentException("The key cannot be negative.");
		}
		else if(getChoices().containsKey(key)) {
			throw new IllegalArgumentException("The key already exists as a static choice.");
		}
		else if(customChoices.containsKey(key)) {
			throw new IllegalArgumentException("The key already exists as a custom choice.");
		}
		
		customChoices.put(key, labelValuePair);
	}
	
	/**
	 * Returns the key for some label.
	 * 
	 * @param label The label.
	 * 
	 * @return The key value.
	 * 
	 * @throws IllegalArgumentException If no such key for the given label 
	 * 									exists.
	 */
	public Integer getChoiceKey(final String label) {
		Map<Integer, LabelValuePair> choices = getAllChoices();
		for(Integer key : choices.keySet()) {
			if(choices.get(key).getLabel().equals(label)) {
				return key;
			}
		}
		
		throw new IllegalArgumentException("No such key for label: " + label);
	}
	
	/**
	 * Returns the label for a key.
	 * 
	 * @param key The key to use to get the label. 
	 * 
	 * @return The key's label.
	 * 
	 * @throws IllegalArgumentException If there is no such key.
	 */
	public String getChoiceLabel(final Integer key) {
		LabelValuePair lvp = getAllChoices().get(key);
		if(lvp == null) {
			throw new IllegalArgumentException("The key is unknown.");
		}
		else {
			return lvp.getLabel();
		}
	}
	
	/**
	 * Removes a custom choice with the given key..
	 * 
	 * @param key The key of the custom choice to remove.
	 * 
	 * @throws IllegalArgumentException Thrown if the key is invalid or belongs
	 * 									to a static choice and not a custom 
	 * 									one.
	 */
	public void removeChoice(final Integer key) {
		if(key == null) {
			throw new IllegalArgumentException("The key cannot be null.");
		}
		else if(key < 0) {
			throw new IllegalArgumentException("The key cannot be negative.");
		}
		else if(getChoices().containsKey(key)) {
			throw new IllegalArgumentException("The key is from a static choice which cannot be removed.");
		}
		
		customChoices.remove(key);
	}
	
	/**
	 * Creates a JSONObject that represents this custom choice prompt.
	 * 
	 * @return A JSONObject that represents this custom choice prompt.
	 */
	@Override
	public JSONObject toJson() {
		try {
			JSONObject result = super.toJson();
			
			if(result == null) {
				// FIXME: Ignore the exception thrown, allowing it to 
				// propagate.
				return null;
			}
			
			JSONObject choiceGlossary = result.getJSONObject(JSON_KEY_CHOICE_GLOSSARY);
			for(Integer key : customChoices.keySet()) {
				choiceGlossary.put(key.toString(), customChoices.get(key).toJson());
			}
			result.put(JSON_KEY_CHOICE_GLOSSARY, choiceGlossary);
			
			return result;
		}
		catch(JSONException e) {
			return null;
		}
	}

	/**
	 * Generates a hash code for this custom choice prompt.
	 * 
	 * @return A hash code for this custom choice prompt.
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = super.hashCode();
		result = prime * result
				+ ((customChoices == null) ? 0 : customChoices.hashCode());
		return result;
	}

	/**
	 * Determines if this custom choice prompt is equivalent to another object.
	 * 
	 * @param obj The other object.
	 * 
	 * @return True if the other object logically equals this custom choice;
	 * 		   false, otherwise.
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (!super.equals(obj))
			return false;
		if (getClass() != obj.getClass())
			return false;
		CustomChoicePrompt other = (CustomChoicePrompt) obj;
		if (customChoices == null) {
			if (other.customChoices != null)
				return false;
		} else if (!customChoices.equals(other.customChoices))
			return false;
		return true;
	}
}