/*******************************************************************************
 * Copyright 2012 The Regents of the University of California
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package org.ohmage.domain.campaign.prompt;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.ohmage.exception.DomainException;

/**
 * This class represents prompts that have a set of choices that are defined by
 * the campaign configuration and have a set of choices that can be added and
 * removed by a user.
 * 
 * @author John Jenkins
 */
public abstract class CustomChoicePrompt extends ChoicePrompt {
	/**
	 * The key to use when exporting this to JSON to indicate the list of 
	 * labels that were predefined for this prompt.
	 */
	public static final String JSON_KEY_FIXED_CHOICES = "fixed_choices";
	
	private final Map<Integer, LabelValuePair> customChoices;
	
	/**
	 * Creates a custom choice prompt.
	 * 
	 * @param id The unique identifier for the prompt within its survey item
	 * 			 group.
	 * 
	 * @param condition The condition determining if this prompt should be
	 * 					displayed.
	 * 
	 * @param unit The unit value for this prompt.
	 * 
	 * @param text The text to be displayed to the user for this prompt.
	 * 
	 * @param explanationText A more-verbose version of the text to be 
	 * 						  displayed to the user for this prompt.
	 * 
	 * @param skippable Whether or not this prompt may be skipped.
	 * 
	 * @param skipLabel The text to show to the user indicating that the prompt
	 * 					may be skipped.
	 * 
	 * @param displayLabel The display label for this prompt.
	 * 
	 * @param choices A map of choices from their integer key value to their
	 * 				  label-value pairs.
	 * 
	 * @param customChoices A map of user-defined map of choices from their
	 * 						integer key value to their lable-value pairs.
	 * 
	 * @param type This prompt's 
	 * 			   {@link org.ohmage.domain.campaign.Prompt.Type}.
	 * 
	 * @param index This prompt's index in its container's list of survey 
	 * 				items.
	 * 
	 * @throws DomainException Thrown if any of the required parameters are 
	 * 						   missing or invalid. 
	 */
	public CustomChoicePrompt(
			final String id, 
			final String condition, 
			final String unit, 
			final String text, 
			final String explanationText,
			final boolean skippable, 
			final String skipLabel,
			final String displayLabel,
			final Map<Integer, LabelValuePair> choices,
			final Map<Integer, LabelValuePair> customChoices, 
			final Type type, 
			final int index) 
			throws DomainException {
		
		super(
			id,
			condition,
			unit,
			text,
			explanationText,
			skippable,
			skipLabel,
			displayLabel,
			choices,
			type,
			index);
		
		Set<String> labels = new HashSet<String>();
		Collection<LabelValuePair> currChoices = 
				new ArrayList<LabelValuePair>(choices.values());
		currChoices.addAll(customChoices.values());
		
		for(LabelValuePair lvp : currChoices) {
			if(! labels.add(lvp.getLabel())) {
				throw new DomainException(
						"Two choices have the same label for prompt '" +
								id +
								"': " +
								lvp.getLabel());
			}
		}
		this.customChoices = new HashMap<Integer, LabelValuePair>(customChoices);
	}
	
	/**
	 * Returns an unmodifiable map of custom choices generated by the user.
	 * 
	 * @return An unmodifiable map of custom choices generated by the user. 
	 */
	public Map<Integer, LabelValuePair> getCustomChoices() {
		return Collections.unmodifiableMap(customChoices);
	}
	
	/**
	 * Returns all of the possible choices, static and custom, as an
	 * unmodifiable map.
	 * 
	 * @return An unmodifiable map of all of the choices, static and custom.
	 */
	public Map<Integer, LabelValuePair> getAllChoices() {
		Map<Integer, LabelValuePair> combinedMap = 
				new HashMap<Integer, LabelValuePair>(customChoices);
		combinedMap.putAll(getChoices());
		
		return Collections.unmodifiableMap(combinedMap);
	}
	
	/**
	 * Adds a new choice to the list of custom choices.
	 * 
	 * @param key The choice's key. Required.
	 * 
	 * @param label The choice's label. Required.
	 * 
	 * @param value The choice's value. Optional.
	 * 
	 * @throws DomainException Thrown if the 'key' or label are invalid or the 
	 * 						   'key' already exists for a static or custom 
	 * 						   choice.
	 */
	public void addChoice(
			final Integer key, 
			final String label, 
			final Number value) 
			throws DomainException {
		
		addChoice(key, new LabelValuePair(label, value));
	}
	
	/**
	 * Adds a new choice to the list of custom choices.
	 * 
	 * @param key The choice's key. Required.
	 * 
	 * @param labelValuePair The choice's label-value pair. Required.
	 * 
	 * @throws DomainException Thrown if the 'key' or label-value pair are 
	 * 						   invalid or if such a choice already exist with 
	 * 						   the given 'key'.
	 */
	public void addChoice(
			final Integer key, 
			final LabelValuePair labelValuePair) 
			throws DomainException {
		
		if(key == null) {
			throw new DomainException("The key cannot be null.");
		}
		else if(key < 0) {
			throw new DomainException("The key cannot be negative.");
		}
		else if(getChoices().containsKey(key)) {
			throw new DomainException(
					"The key already exists as a static choice.");
		}
		else if(customChoices.containsKey(key)) {
			throw new DomainException(
					"The key already exists as a custom choice.");
		}
		
		customChoices.put(key, labelValuePair);
	}
	
	/**
	 * Returns the key for some label.
	 * 
	 * @param label The label.
	 * 
	 * @return The key value.
	 * 
	 * @throws DomainException If no such key for the given label exists.
	 */
	public Integer getChoiceKey(final String label) throws DomainException {
		Map<Integer, LabelValuePair> choices = getAllChoices();
		for(Integer key : choices.keySet()) {
			if(choices.get(key).getLabel().equals(label)) {
				return key;
			}
		}
		
		throw new DomainException("No such key for label: " + label);
	}
	
	/**
	 * Returns the label for a key.
	 * 
	 * @param key The key to use to get the label. 
	 * 
	 * @return The key's label.
	 * 
	 * @throws DomainException If there is no such key.
	 */
	public String getChoiceLabel(final Integer key) throws DomainException {
		LabelValuePair lvp = getAllChoices().get(key);
		if(lvp == null) {
			throw new DomainException("The key is unknown.");
		}
		else {
			return lvp.getLabel();
		}
	}
	
	/**
	 * Removes a custom choice with the given key..
	 * 
	 * @param key The key of the custom choice to remove.
	 * 
	 * @throws DomainException Thrown if the key is invalid or belongs to a 
	 * 						   static choice and not a custom one.
	 */
	public void removeChoice(final Integer key) throws DomainException {
		if(key == null) {
			throw new DomainException("The key cannot be null.");
		}
		else if(key < 0) {
			throw new DomainException("The key cannot be negative.");
		}
		else if(getChoices().containsKey(key)) {
			throw new DomainException(
					"The key is from a static choice which cannot be removed.");
		}
		
		customChoices.remove(key);
	}
	
	/**
	 * Creates a JSONObject that represents this custom choice prompt.
	 * 
	 * @return A JSONObject that represents this custom choice prompt.
	 * 
	 * @throws JSONException There was a problem creating the JSONObject.
	 */
	@Override
	public JSONObject toJson() throws JSONException {
		JSONObject result = super.toJson();
		
		JSONObject choiceGlossary = 
				result.getJSONObject(JSON_KEY_CHOICE_GLOSSARY);
		for(Integer key : customChoices.keySet()) {
			choiceGlossary.put(key.toString(), customChoices.get(key).toJson());
		}
		result.put(JSON_KEY_CHOICE_GLOSSARY, choiceGlossary);
		
		JSONArray labels = new JSONArray();
		for(LabelValuePair lvp : getChoices().values()) {
			labels.put(lvp.getLabel());
		}
		result.put(JSON_KEY_FIXED_CHOICES, labels);
		
		return result;
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = super.hashCode();
		result =
			prime *
				result +
				((customChoices == null) ? 0 : customChoices.hashCode());
		return result;
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj) {
		if(this == obj) {
			return true;
		}
		if(!super.equals(obj)) {
			return false;
		}
		if(!(obj instanceof CustomChoicePrompt)) {
			return false;
		}
		CustomChoicePrompt other = (CustomChoicePrompt) obj;
		if(customChoices == null) {
			if(other.customChoices != null) {
				return false;
			}
		}
		else if(!customChoices.equals(other.customChoices)) {
			return false;
		}
		return true;
	}
}
